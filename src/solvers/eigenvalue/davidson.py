#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Jun  7 13:17:55 2022@author: sampasmann"""import numpy as npimport scipy.linalg as spfrom src.solvers.eigenvalue.maps import SI_Mapdef AxV(V, qmc_data):    """    Linear operator for scattering term (I-L^(-1)S)*phi    """    Nx  = qmc_data.Nx    G   = qmc_data.G    Nv  = Nx*G    zed = np.zeros((Nx,G))    axv = np.empty(V.shape)    for i in range(V.shape[1]):        phi_in = np.reshape(V[:,i], (Nv,1))        axv[:,i] = phi_in[:,0] - SI_Map(zed, phi_in, qmc_data)[:,0]            return axvdef BxV(V, qmc_data):    """    Linear operator for fission term (L^(-1)F*phi)    """    Nx  = qmc_data.Nx    G   = qmc_data.G    Nv  = Nx*G    zed = np.zeros((Nx,G))    bxv = np.empty(V.shape)    for i in range(V.shape[1]):        phi_in = np.reshape(V[:,i], (Nv,1))        bxv[:,i]  = SI_Map(phi_in, zed, qmc_data)[:,0]            return bxvdef PreConditioner(V,qmc_data, numSweeps=5):    """    Linear operator approximation of L^(-1)S        In this case the preconditioner is a specified number of purely scattering    transport sweeps.    """    maxit   = 10    tol     = 1e-6    Nx      = qmc_data.Nx    G       = qmc_data.G    Nv      = Nx*G    t       = np.empty(V.shape)    zed     = np.zeros((Nv,1))    for i in range(V.shape[1]):        phi_in = np.reshape(V[:,i], (Nv,1))        for j in range(numSweeps):            phi_in = SI_Map(zed, phi_in, qmc_data)        t[:,i] = phi_in[:,0]    return tdef Gram(V,u):    w1  = u - np.dot(V,np.dot(V.T,u))    v1  = w1 / np.linalg.norm(w1)    w2  = v1 - np.dot(V,np.dot(V.T,v1))    v2  = w2 / np.linalg.norm(w2)    V   = np.append(V, v2, axis=1)    return Vdef Davidson(qmc_data, k0=1.0, l=1, m=5, numSweeps=5, tol=1e-6, maxit=30):    # Davidson Parameters    u       = qmc_data.source.copy()    V       = np.array(u/np.linalg.norm(u).T) # orthonormalize initial guess    Lambda0 = 1/k0    k_old   = 0.0    dk      = 1.0    r0      = AxV(V, qmc_data) - Lambda0*BxV(V, qmc_data) # (A - keff*B)V_0    r       = r0    itt     = 1        # Davidson Routine    while (itt <= maxit) and (dk>=tol):        print(" Davidson Iteration: ", itt)        AV          = np.dot(V.T, AxV(V, qmc_data)) # Scattering linear operator        BV          = np.dot(V.T, BxV(V, qmc_data)) # Fission linear operator        [Lambda, w] = sp.eig(AV, b=BV)  # solve for eigenvalues and vectors        idx         = Lambda.argsort()  # get indices of eigenvalues from smallest to largest        Lambda      = Lambda[idx]       # sort eigenvalues from smalles to largest        assert(Lambda.imag.all() == 0.0)# there can't be any imaginary eigenvalues        Lambda      = Lambda[:l].real   # take the real component of the l largest eigenvalues        k           = 1/Lambda        dk          = abs(k - k_old)        print("dk: ",dk)        print(V.shape)        k_old       = k        w           = w[:,idx]          # sort corresponding eigenvector        w           = w[:,:l].real      # take the l largest eigenvectors        u           = np.dot(V,w)       # Ritz vectors        r           = AxV(u, qmc_data) - Lambda*BxV(u, qmc_data) # residual        t           = PreConditioner(r, qmc_data, numSweeps)        if (V.shape[1] <= m-l ):            V = Gram(V,t) # appends new orthogonalization to V        else:            V = Gram(u,t) # "restarts" by appending to a new array         if (itt==maxit):            print("Maximum number of iterations")            break        itt += 1        keff = 1/Lambda    phi  = V[:,0]    phi = phi/np.linalg.norm(phi).T    return phi, keff, itt